<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Again on feeds in Gemini format
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:gemini%40lists.orbitalfox.eu?Subject=Re%3A%20Again%20on%20feeds%20in%20Gemini%20format&In-Reply-To=%3C6cf7601b-4592-d77a-c57a-272ec15730fc%40emilis.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003396.html">
   <LINK REL="Next"  HREF="003408.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Again on feeds in Gemini format</H1>
    <B>Emilis</B> 
    <A HREF="mailto:gemini%40lists.orbitalfox.eu?Subject=Re%3A%20Again%20on%20feeds%20in%20Gemini%20format&In-Reply-To=%3C6cf7601b-4592-d77a-c57a-272ec15730fc%40emilis.net%3E"
       TITLE="Again on feeds in Gemini format">emilis at emilis.net
       </A><BR>
    <I>Thu Nov 19 01:12:42 GMT 2020</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="003396.html">[ANN] Gemini historical snapshot
</A></li>
        <LI>Next message (by thread): <A HREF="003408.html">Again on feeds in Gemini format
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3407">[ date ]</a>
              <a href="thread.html#3407">[ thread ]</a>
              <a href="subject.html#3407">[ subject ]</a>
              <a href="author.html#3407">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

I am developing a generator and a parser for the 
frequently-discussed-but-never-agreed-on feeds in Gemini format.

I would like to share my code, see your similar code and later discuss 
(over IRC?) what format could work best for our use cases.

My code:

Gemlog generator: <A HREF="gemini://tilde.team/~emilis/Makefile">gemini://tilde.team/~emilis/Makefile</A>
Aggregator: <A HREF="https://tildegit.org/emilis/gmi-feed-aggregator">https://tildegit.org/emilis/gmi-feed-aggregator</A>


The motivation (taken from this post: 
<A HREF="gemini://tilde.team/~emilis/2020/11/19-on-feeds-in-gemini-format.gmi">gemini://tilde.team/~emilis/2020/11/19-on-feeds-in-gemini-format.gmi</A> ):


I looked through the discussions on Gemini list, read the posts by ~ew0k 
and Drew DeVault.

I wholeheartedly disagree with the opinion that Atom/RSS (or JSON feeds) 
should be enough for everybody.

The point is - some of us are not thinking about running feed 
generators, parsers and aggregators on developer laptops, workstations, 
modern servers we own, etc..

We are thinking about running these programs on computers where we have 
limited permissions, OpenWRT routers, experimental SBCs, old netbooks 
and rooted phones that cannot be updated to any recent distros, etc..

In these situations even Python (widespread as it is) may not be 
available, may be too resource-hungry or may not have the option to be 
updated or extended with libraries.

What we need is the ability to process feeds with a bare minimum of 
tools (e.g. a POSIX shell, BusyBox, etc.). Parsing XML and JSON is not 
feasible in these situations.

Therefore we want a plain Gemini feed format. Seeing how easy it is to 
generate and parse Gemini files with just plain shell script, makes us 
want it badly. We also have hopes it would have more uses than just 
gemlogging.

## What should we do about it

I think we should start by just building the tools for ourselves and 
sharing them (probably on the Gemini list). After we have a few 
implementations, we can discuss on the formal spec between the developers.

The main criteria should probably be the amount of effort and knowledge 
needed to implement a parser.

What I found in the discussions is that this may be the lowest common 
denominator at the moment:

```
=&gt; URL ISO-TIMESTAMP TITLE-MAYBE-WITH-AUTHOR
```

We can start from this and agree that our parsers will rely on just 
these lines and ignore the rest for the moment. It could be done by this 
command:

```
grep -E '^=&gt;\s*<A HREF="gemini://[^">gemini://[^</A> ]+ 
[0-9]{4}-[0-9]{2}-[0-9]{2}(T[0-9]{2}:[0-9]{2}:[0-9]{2}(Z|\+[0-9]{1,2}:[0-9]{2}))?\s+.*$'
```


Looking forward to seeing your implementations. Please share them!


--
Emilis Dambauskas
<A HREF="gemini://tilde.team/~emilis/">gemini://tilde.team/~emilis/</A>

</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="003396.html">[ANN] Gemini historical snapshot
</A></li>
	<LI>Next message (by thread): <A HREF="003408.html">Again on feeds in Gemini format
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3407">[ date ]</a>
              <a href="thread.html#3407">[ thread ]</a>
              <a href="subject.html#3407">[ subject ]</a>
              <a href="author.html#3407">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.orbitalfox.eu/listinfo/gemini">More information about the Gemini
mailing list</a><br>
</body></html>
